//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18063
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

// 
// 此源代码由 wsdl 自动生成, Version=4.0.30319.1。
// 
namespace wsdlLib {
    using System.Diagnostics;
    using System;
    using System.Xml.Serialization;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="PdfSignGJSoap11Binding", Namespace="http://test.webservice")]
    public partial class PdfSignGJ : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback KeySignOperationCompleted;
        
        private System.Threading.SendOrPostCallback getSealIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback XYSignOperationCompleted;
        
        private System.Threading.SendOrPostCallback QFSignOperationCompleted;
        
        /// <remarks/>
        public PdfSignGJ() {
            this.Url = "http://172.16.90.20:8080/pdfGJ/services/PdfSignGJ.PdfSignGJHttpSoap11Endpoint/";
        }
        
        /// <remarks/>
        public event KeySignCompletedEventHandler KeySignCompleted;
        
        /// <remarks/>
        public event getSealIdCompletedEventHandler getSealIdCompleted;
        
        /// <remarks/>
        public event XYSignCompletedEventHandler XYSignCompleted;
        
        /// <remarks/>
        public event QFSignCompletedEventHandler QFSignCompleted;

        /**
	 * 关键字签章
	 * @param KEY_WORD  关键字   若多次出现，只取最后一个
	 * @param signDocPath  需要盖章的文档位置
	 * @param sealParentPath  存放印章（xml）和张三（pfx）文件的文件夹路径 
	 * @param xmlName  印章名称
	 * @param pfxPwd  证书密码
	 * @param saveLib  存放盖完章文件的文件夹
	 * @param savePdfName  盖完章文件的文件名
	 * @return "1":盖章成功   "0"盖章失败
	 */
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:KeySign", RequestNamespace="http://test.webservice", ResponseNamespace="http://test.webservice", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("return", IsNullable=true)]
        public string KeySign([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string KEY_WORD, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string signDocPath, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string sealParentPath, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string xmlName, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string pfxPwd, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string saveLib, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string savePdfName) {
            object[] results = this.Invoke("KeySign", new object[] {
                        KEY_WORD,
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        saveLib,
                        savePdfName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginKeySign(string KEY_WORD, string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string saveLib, string savePdfName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("KeySign", new object[] {
                        KEY_WORD,
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        saveLib,
                        savePdfName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndKeySign(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void KeySignAsync(string KEY_WORD, string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string saveLib, string savePdfName) {
            this.KeySignAsync(KEY_WORD, signDocPath, sealParentPath, xmlName, pfxPwd, saveLib, savePdfName, null);
        }
        
        /// <remarks/>
        public void KeySignAsync(string KEY_WORD, string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string saveLib, string savePdfName, object userState) {
            if ((this.KeySignOperationCompleted == null)) {
                this.KeySignOperationCompleted = new System.Threading.SendOrPostCallback(this.OnKeySignOperationCompleted);
            }
            this.InvokeAsync("KeySign", new object[] {
                        KEY_WORD,
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        saveLib,
                        savePdfName}, this.KeySignOperationCompleted, userState);
        }
        
        private void OnKeySignOperationCompleted(object arg) {
            if ((this.KeySignCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.KeySignCompleted(this, new KeySignCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:getSealId", RequestNamespace="http://test.webservice", ResponseNamespace="http://test.webservice", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("return", IsNullable=true)]
        public string getSealId([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string xmlPath) {
            object[] results = this.Invoke("getSealId", new object[] {
                        xmlPath});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BegingetSealId(string xmlPath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("getSealId", new object[] {
                        xmlPath}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndgetSealId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void getSealIdAsync(string xmlPath) {
            this.getSealIdAsync(xmlPath, null);
        }
        
        /// <remarks/>
        public void getSealIdAsync(string xmlPath, object userState) {
            if ((this.getSealIdOperationCompleted == null)) {
                this.getSealIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OngetSealIdOperationCompleted);
            }
            this.InvokeAsync("getSealId", new object[] {
                        xmlPath}, this.getSealIdOperationCompleted, userState);
        }
        
        private void OngetSealIdOperationCompleted(object arg) {
            if ((this.getSealIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.getSealIdCompleted(this, new getSealIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /**
	 * 坐标签章
	 * @param signDocPath  需要盖章的文档位置
	 * @param sealParentPath  存放印章（xml）和张三（pfx）文件的文件夹路径 
	 * @param xmlName  印章名称
	 * @param pfxPwd  证书密码
	 * @param strpage  依次盖的几个章的页数
	 * @param strx  依次需要盖的几个章的x轴位置
	 * @param stry  依次需要盖的几个章的y轴位置
	 * @param saveLib  存放盖完章文件的文件夹
	 * @param savePdfName  盖完章文件的文件名
	 * @return "1":盖章成功   "0"盖章失败
	 */
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:XYSign", RequestNamespace="http://test.webservice", ResponseNamespace="http://test.webservice", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("return", IsNullable=true)]
        public string XYSign([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string signDocPath, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string sealParentPath, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string xmlName, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string pfxPwd, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string strpage, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string strx, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string stry, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string saveLib, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string savePdfName) {
            object[] results = this.Invoke("XYSign", new object[] {
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        strpage,
                        strx,
                        stry,
                        saveLib,
                        savePdfName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginXYSign(string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string strpage, string strx, string stry, string saveLib, string savePdfName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("XYSign", new object[] {
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        strpage,
                        strx,
                        stry,
                        saveLib,
                        savePdfName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndXYSign(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void XYSignAsync(string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string strpage, string strx, string stry, string saveLib, string savePdfName) {
            this.XYSignAsync(signDocPath, sealParentPath, xmlName, pfxPwd, strpage, strx, stry, saveLib, savePdfName, null);
        }
        
        /// <remarks/>
        public void XYSignAsync(string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string strpage, string strx, string stry, string saveLib, string savePdfName, object userState) {
            if ((this.XYSignOperationCompleted == null)) {
                this.XYSignOperationCompleted = new System.Threading.SendOrPostCallback(this.OnXYSignOperationCompleted);
            }
            this.InvokeAsync("XYSign", new object[] {
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        strpage,
                        strx,
                        stry,
                        saveLib,
                        savePdfName}, this.XYSignOperationCompleted, userState);
        }
        
        private void OnXYSignOperationCompleted(object arg) {
            if ((this.XYSignCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.XYSignCompleted(this, new XYSignCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /**
	 * 骑缝签章
	 * @param signDocPath  需要盖章的文档位置
	 * @param sealParentPath  存放印章（xml）和张三（pfx）文件的文件夹路径 
	 * @param xmlName  印章名称
	 * @param pfxPwd  证书密码
	 * @param saveLib  存放盖完章文件的文件夹
	 * @param savePdfName  盖完章文件的文件名
	 * @return "1":盖章成功   "0"盖章失败
	 */
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:QFSign", RequestNamespace="http://test.webservice", ResponseNamespace="http://test.webservice", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("return", IsNullable=true)]
        public string QFSign([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string signDocPath, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string sealParentPath, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string xmlName, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string pfxPwd, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string saveLib, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string savePdfName) {
            object[] results = this.Invoke("QFSign", new object[] {
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        saveLib,
                        savePdfName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQFSign(string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string saveLib, string savePdfName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QFSign", new object[] {
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        saveLib,
                        savePdfName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndQFSign(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void QFSignAsync(string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string saveLib, string savePdfName) {
            this.QFSignAsync(signDocPath, sealParentPath, xmlName, pfxPwd, saveLib, savePdfName, null);
        }
        
        /// <remarks/>
        public void QFSignAsync(string signDocPath, string sealParentPath, string xmlName, string pfxPwd, string saveLib, string savePdfName, object userState) {
            if ((this.QFSignOperationCompleted == null)) {
                this.QFSignOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQFSignOperationCompleted);
            }
            this.InvokeAsync("QFSign", new object[] {
                        signDocPath,
                        sealParentPath,
                        xmlName,
                        pfxPwd,
                        saveLib,
                        savePdfName}, this.QFSignOperationCompleted, userState);
        }
        
        private void OnQFSignOperationCompleted(object arg) {
            if ((this.QFSignCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QFSignCompleted(this, new QFSignCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void KeySignCompletedEventHandler(object sender, KeySignCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class KeySignCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal KeySignCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void getSealIdCompletedEventHandler(object sender, getSealIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class getSealIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal getSealIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void XYSignCompletedEventHandler(object sender, XYSignCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class XYSignCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal XYSignCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void QFSignCompletedEventHandler(object sender, QFSignCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QFSignCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QFSignCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
